#+TITLE Literate Init File for FTWynn
#+PROPERTY: header-args:emacs-lisp 

* General.el

This seems to be a big keybinding library everyone uses.

Putting it first because a bunch of use-package definitions might need it.

#+begin_src emacs-lisp
  (straight-use-package 'general)

  (use-package general
  :config
  (general-evil-setup t)

  (general-create-definer ftwynn/leader-key-def
    :keymaps '(normal insert visual emacs)
    :prefix "SPC"
    :global-prefix "C-SPC")

  (general-create-definer ftwynn/ctrl-c-keys
    :prefix "C-c"))
  
  ;;(require 'general)
#+end_src

I can just add whatever I want to the leader-key-def to set up the map. It works in any block just as below.

#+begin_src emacs-lisp
    (ftwynn/leader-key-def
    "fn" '((lambda () (interactive) (find-file "~/org-roam-repo/")) :which-key "org-roam files")
    "fd"  '(:ignore t :which-key "dotfiles")
    "fdl" '((lambda () (interactive) (find-file "~/dotfiles/.emacs/literate_init.org")) :which-key "literate init")
    "fr" '((lambda () (interactive) (recentf-open-files )) :which-key "recent files")
    ;;"fde" '((lambda () (interactive) (find-file (expand-file-name "~/.dotfiles/Emacs.org"))) :which-key "edit config")
    ;;"fdE" '((lambda () (interactive) (dw/org-file-show-headings "~/.dotfiles/Emacs.org")) :which-key "edit config")
    ;;"fdm" '((lambda () (interactive) (find-file "~/.dotfiles/Mail.org")) :which-key "mail")
    ;;"fdM" '((lambda () (interactive) (counsel-find-file "~/.dotfiles/.config/guix/manifests/")) :which-key "manifests")
    ;;"fds" '((lambda () (interactive) (dw/org-file-jump-to-heading "~/.dotfiles/Systems.org" "Base Configuration")) :which-key "base system")
    ;;"fdS" '((lambda () (interactive) (dw/org-file-jump-to-heading "~/.dotfiles/Systems.org" system-name)) :which-key "this system")
    ;;"fdp" '((lambda () (interactive) (dw/org-file-jump-to-heading "~/.dotfiles/Desktop.org" "Panel via Polybar")) :which-key "polybar")
    ;;"fdw" '((lambda () (interactive) (find-file (expand-file-name "~/.dotfiles/Workflow.org"))) :which-key "workflow")
    ;;"fdv" '((lambda () (interactive) (find-file "~/.dotfiles/.config/vimb/config")) :which-key "vimb")
  )
#+end_src

* Startup and Display Properties

** Start out maximized with no splash screen

#+begin_src emacs-lisp
  (setq default-frame-alist '((fullscreen . maximized)))
  (setq inhibit-startup-screen t)
#+end_src

** Turning off most of the frame stuff

Leaving menu-bar on for discoverability as I re-learn

#+begin_src emacs-lisp
  (menu-bar-mode 1) 
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

** Nicer font please!

Height is 1/10th of a point here.

They both *should* work, but the latter seems more modern

#+begin_src emacs-lisp
  ;;(set-frame-font "Fira Code 18")
  (set-face-attribute 'default nil :font "Fira Code" :height 180)

#+end_src

** Visible Bell

I'm tinkering with a visible bell. It's nice feedback when I
don't have headphones on

#+begin_src emacs-lisp
  (setq visible-bell t)
#+end_src

** Line and Column Numbers
Don't display line numbers in every buffer... but I'm not sure
I really need this

#+begin_src emacs-lisp
  (global-display-line-numbers-mode 1)
  (column-number-mode)
#+end_src

Disable in some buffers

#+begin_src emacs-lisp
    (dolist (mode '(term-mode-hook
		    eshell-mode-hook
		    shell-mode-hook))
      (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src

** Rainbow Delimeters

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Native Dialog Boxes

Don't pop up UI dialogs when prompting, sticking to the more kweyboard native stuff
#+begin_src emacs-lisp
  (setq use-dialog-box nil)
#+end_src

** Watch Files on Disk (aka Revert)

Watch files on disk and generally keep them in sync with buffers

#+begin_src emacs-lisp
  ;; Revert buffers when the underlying file has changed
  ;; aka, watch files on disk and reload those changes if another program messes with them
  (global-auto-revert-mode 1)

  ;; Revert Dired and other buffers
  (setq global-auto-revert-non-file-buffers t)
#+end_src

** Word Wrapping

~visual-line-mode~ is what we're looking for

Note, some operations work on these virtual "screen" lines, like C-k, C-a, and C-e. M- prefixes do the logical lines... or maybe sentences?

#+begin_src emacs-lisp
  (global-visual-line-mode 1)
#+end_src

* Some Basic Org Setup

Tempo (from contrib) makes the ~<s <TAB>~ shortcode work

Gotta get org-roam in there too of course

#+begin_src emacs-lisp
  (straight-use-package 'org-contrib)
  (require 'org-tempo)
  
  (straight-use-package 'org-roam)
#+end_src

* Magit

It's magit. Enough said.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-M-;" . magit-status)
    :commands (magit-status magit-get-current-branch)
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  (ftwynn/leader-key-def
    "g"   '(:ignore t :which-key "git")
    "gs"  'magit-status
    "gd"  'magit-diff-unstaged
    "gc"  'magit-branch-or-checkout
    "gl"   '(:ignore t :which-key "log")
    "glc" 'magit-log-current
    "glf" 'magit-log-buffer-file
    "gb"  'magit-branch
    "gP"  'magit-push-current
    "gp"  'magit-pull-branch
    "gf"  'magit-fetch
    "gF"  'magit-fetch-all
    "gr"  'magit-rebase)
#+END_SRC

** Magit TODOs

Should show all the lines with TODO, so I don't need to shoehorn them into Org headlines.

Didn't seem to work though, so I'm skipping for now

;;    (use-package magit-todos
;;      :defer t)

;;  (ftwynn/leader-key-def
;;    "gt" 'magit-todos-list)

* Mastering Emacs Lifts

** TODO Explore different completion frameworks

Remember M-j takes your current typings and runs with it to make new files

Fido is the easiest drop in replacement for now.

Vertico seems to be what the cool kids are using.

;(fido-vertical-mode 1)

** Change Buffer List to ibuffer

Seems nicer. I'll keep it for now.

#+begin_src emacs-lisp
  (global-set-key [remap list-buffers] 'ibuffer)
  (global-set-key (kbd "M-o") 'other-window)
#+end_src

** Minibuffer History

;; Save what you enter into minibuffer prompts to cycle thorugh with M-p and M-n
#+begin_src emacs-lisp
  (setq history-length 25)
  (savehist-mode 1)
#+end_src

** Remember Cursor Placement

Remember and restore the last cursor location of opened files

#+begin_src emacs-lisp
  (save-place-mode 1)
#+end_src

** Recent Files

;; Make recent files a thing with M-x recentf-open-files
#+begin_src emacs-lisp
  (recentf-mode 1)
#+end_src

* Cleaning Up Files

** Need to look into the nolitter package

** Set Customize vars in a different file

Move automated customization variables to a separate file and load it
#+begin_src emacs-lisp
  (setq custom-file (locate-user-emacs-file "custom-vars.el"))
  (load custom-file 'noerror 'nomessage)
#+end_src

* Chromebook Platform Specific

** TODO Need to remap Page Up and Down

This org-mode-map doesn't seem to work anymore... needs more homework

shell-command of uname -r should give similar to:
5.10.159-20950-g396322d9eb4

The g looks to be consistent

;(define-key org-mode-map (kbd "<prior>") 'org-metaup)
;(define-key org-mode-map (kbd "<next>") 'org-metadown)

* Windows Platform Specific
* OSX Platform Specific
* Themes
** Modus Theme Customizations

There's a lot of configs in here...

There are someone else's suggestions... they seem ok

Not sure if I want to reskin the colors at some point

There's also a *lot* that borders on non-theme stuff
- Rainbow parens
- Completions
- Etc

#+begin_src emacs-lisp
(setq modus-themes-mode-line '(accented borderless)
      modus-themes-bold-constructs t
      modus-themes-italic-constructs t
      modus-themes-fringes 'subtle
      modus-themes-tabs-accented t
      modus-themes-paren-match '(bold intense)
      modus-themes-prompts '(bold intense)
      modus-themes-completions 'opinionated
      modus-themes-org-blocks 'tinted-background
      modus-themes-scale-headings t
      modus-themes-region '(bg-only)
      modus-themes-headings
      '((1 . (rainbow overline background 1.4))
        (2 . (rainbow background 1.3))
        (3 . (rainbow bold 1.2))
	(4 . (rainbow bold 1.2))
	(5 . (rainbow bold 1.2))
	(6 . (rainbow bold 1.2))
	(7 . (rainbow bold 1.2))
	(8 . (rainbow bold 1.2))
        (t . (semilight 1.1))))
#+end_src

#+begin_src emacs-lisp
  (load-theme 'modus-vivendi)
#+end_src

* Doom Steals

** Doom Modeline

It's prettier by default, let's try it!

#+begin_src emacs-lisp
  (use-package doom-modeline
    :init (doom-modeline-mode 1))
#+end_src

It apparently needs some fonts

*Need to run*
M-x all-the-icons-install-fonts
AFTER this is installed the first time on a new system (Linux or OSX)

#+begin_src emacs-lisp
  (use-package all-the-icons
    :if (display-graphic-p))
#+end_src

* Completions

** Which-key

Dat sweet sweet wtf does this key-combo do

#+begin_src emacs-lisp
  (use-package which-key
    :init (which-key-mode)
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 0.03))
#+end_src

** Vertico

It's more idiomatic emacs... a wonder it took this long to get popular

#+begin_src emacs-lisp
  ;; Enable vertico
  (use-package vertico
    :init
    (vertico-mode)

    ;; Different scroll margin
    ;; (setq vertico-scroll-margin 0)

    ;; Show more candidates
    (setq vertico-count 15)

    ;; Grow and shrink the Vertico minibuffer
    (setq vertico-resize t)

    ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
    (setq vertico-cycle nil)

    :general
    (:keymaps 'vertico-map
	      "<tab>" #'vertico-insert  ; Insert selected candidate into text area
	      "<escape>" #'minibuffer-keyboard-quit ; Close minibuffer
	      ;; NOTE 2022-02-05: Cycle through candidate groups
	      "C-M-n" #'vertico-next-group
	      "C-M-p" #'vertico-previous-group)
    )

#+end_src

** Orderless

This appears to be important for... fuzzy matching I think?

;;#+begin_src emacs-lisp
  ;; Optionally use the `orderless' completion style.
  (use-package orderless
    :init
    ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setq orderless-style-dispatchers '(+orderless-consult-dispatch orderless-affix-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setq completion-styles '(orderless basic)
	  completion-category-defaults nil
	  completion-category-overrides '((file (styles partial-completion)))))

;;#+end_src

Trying a much more involved version from a blog post to see how it feels.

The above is just the docs' basic recommendation.

#+begin_src emacs-lisp
  (use-package orderless
    :custom
    (completion-styles '(orderless))
    (completion-category-defaults nil)    ; I want to be in control!
    (completion-category-overrides
     '((file (styles basic-remote ; For `tramp' hostname completion with `vertico'
		     orderless
		     ))
       ))
    
    (orderless-component-separator 'orderless-escapable-split-on-space)
    (orderless-matching-styles
     '(orderless-literal
       orderless-prefixes
       orderless-initialism
       orderless-regexp
       ;; orderless-flex
       ;; orderless-strict-leading-initialism
       ;; orderless-strict-initialism
       ;; orderless-strict-full-initialism
       ;; orderless-without-literal          ; Recommended for dispatches instead
       ))
    (orderless-style-dispatchers
     '(prot-orderless-literal-dispatcher
       prot-orderless-strict-initialism-dispatcher
       prot-orderless-flex-dispatcher
       ))
    :init
    (defun orderless--strict-*-initialism (component &optional anchored)
      "Match a COMPONENT as a strict initialism, optionally ANCHORED.
  The characters in COMPONENT must occur in the candidate in that
  order at the beginning of subsequent words comprised of letters.
  Only non-letters can be in between the words that start with the
  initials.

  If ANCHORED is `start' require that the first initial appear in
  the first word of the candidate.  If ANCHORED is `both' require
  that the first and last initials appear in the first and last
  words of the candidate, respectively."
      (orderless--separated-by
	  '(seq (zero-or-more alpha) word-end (zero-or-more (not alpha)))
	(cl-loop for char across component collect `(seq word-start ,char))
	(when anchored '(seq (group buffer-start) (zero-or-more (not alpha))))
	(when (eq anchored 'both)
	  '(seq (zero-or-more alpha) word-end (zero-or-more (not alpha)) eol))))

    (defun orderless-strict-initialism (component)
      "Match a COMPONENT as a strict initialism.
  This means the characters in COMPONENT must occur in the
  candidate in that order at the beginning of subsequent words
  comprised of letters.  Only non-letters can be in between the
  words that start with the initials."
      (orderless--strict-*-initialism component))

    (defun prot-orderless-literal-dispatcher (pattern _index _total)
      "Literal style dispatcher using the equals sign as a suffix.
  It matches PATTERN _INDEX and _TOTAL according to how Orderless
  parses its input."
      (when (string-suffix-p "=" pattern)
	`(orderless-literal . ,(substring pattern 0 -1))))

    (defun prot-orderless-strict-initialism-dispatcher (pattern _index _total)
      "Leading initialism  dispatcher using the comma suffix.
  It matches PATTERN _INDEX and _TOTAL according to how Orderless
  parses its input."
      (when (string-suffix-p "," pattern)
	`(orderless-strict-initialism . ,(substring pattern 0 -1))))

    (defun prot-orderless-flex-dispatcher (pattern _index _total)
      "Flex  dispatcher using the tilde suffix.
  It matches PATTERN _INDEX and _TOTAL according to how Orderless
  parses its input."
      (when (string-suffix-p "." pattern)
	`(orderless-flex . ,(substring pattern 0 -1))))
    )
#+end_src


** Consult

This may not be necessary with marginalia?

https://kristofferbalintona.me/posts/202202211546/

The above post doesn't use it... I'd have to check what it does to see if I really need it

** Marginalia

#+begin_src emacs-lisp
  (use-package marginalia
    ;:general
    ;(:keymaps 'minibuffer-local-map
	      ;"M-A" 'marginalia-cycle)
    :custom
    (marginalia-max-relative-age 0)
    (marginalia-align 'right)
    :init
    (marginalia-mode))

#+end_src

That gives nice text, but there's icons too with all-the-icons!

#+begin_src emacs-lisp
  (use-package all-the-icons-completion
    :after (marginalia all-the-icons)
    :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
    :init
    (all-the-icons-completion-mode))
#+end_src

* Evil Mode

I'm not philosophicaly opposed to emacs bindings, but I do think my hands, even with remapping the CAPS LOCK key, can't quite take it. I'll take the inefficiencies of figuring out the evilness of things and the occaisional longer keystrokes over constant chords.

TODO I'll want to make sure it plays nice with ~which-key~

** Base Evil mode

https://www.youtube.com/watch?v=xaZMwNELaJY&list=PLEoMzSkcN8oPH1au7H6B7bBJ4ZO7BXjSZ&index=3

Taking lots of config cues from the above. Basically targeting buffer editing for vim, then emacs for the rest.

Remember C-z switches to emacs mode. C-w does window operations

#+begin_src emacs-lisp
  (defun ftwynn/evil-emacs-mode-selections ()
    (dolist (mode '(custom-mode
		    eshell-mode
		    git-rebase-mode
		    erc-mode
		    circe-server-mode
		    circe-chat-mode
		    circe-query-mode
		    sauron-mode
		    term-mode))
    (add-to-list 'evil-emacs-state-modes mode)))




    (use-package evil
	:init
	(setq evil-want-integration t)
	(setq evil-want-keybinding nil)
	(setq evil-want-c-u-scroll t)
	(setq evil-respect-visual-line-mode t)
	:config
	(add-hook 'evil-mode-hook 'ftwynn/evil-emacs-mode-selections)
	(evil-mode 1)
	(define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
	(define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

	;; Use visual line motions even outside of visual-line mode, because they use logical lines otherwise
	(evil-global-set-key 'motion "j" 'evil-next-visual-line)
	(evil-global-set-key 'motion "k" 'evil-previous-visual-line))
#+end_src

** Evil-collection

Lots of premade bindings. We'll see if I like them.

#+begin_src emacs-lisp
  (use-package evil-collection
  :after evil
  :config
  (evil-collection-init))
#+end_src

* Projectile

Mostly good for directory level search I'm told. 

#+begin_src emacs-lisp
  (use-package projectile
  :diminish projectile-mode
  :config (projectile-mode)
  :demand t
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :init
  (when (file-directory-p "~/org-roam-repo")
    (setq projectile-project-search-path '("~/org-roam-repo"))))

  (ftwynn/leader-key-def
  "pf"  'projectile-find-file
  "ps"  'projectile-switch-project
  "pF"  'projectile-ripgrep
  "pe"  'projectile-run-eshell
  ;;"pp"  'counsel-projectile
  "pc"  'projectile-compile-project
  "pd"  'projectile-dired)

#+end_src

* TODOs

** TODO Look into God mode to cut down on the modifier keys

** TODO look into Avy for onscreen text jumping instead of isearch

** TODO look into swiper or isearch or CTRLF for searching within a buffer

** TODO Look into directory wide searching and stuff with rg or projectile or whatever
